# 链表

## 逆序问题

1. 普通逆序

   ``` java
   /**
    * 方法1： 最简单且好理解的方法
    */
   public ListNode reverseList(ListNode head) {
       ListNode pre = null, curr = head; // 双指针
       while (curr != null) {
           // 1. 暂存next， 将curr指针逆向
           ListNode next = curr.next;
           curr.next = pre;
   
           // 2. 双指针后移
           pre = curr;
           curr = next;
       }
       return pre;
   }
   
   /**
    * 方法2： 头插法。 该方法会保持curr指向尾巴结点，在一些场景很有用
    */
   public ListNode reverseList2(ListNode head) {
       ListNode dummy = new ListNode(0, head); // dummy结点始终在最前面
       ListNode curr = head;
   
       if (curr == null) {return curr;}
   
       while (curr.next != null) {
           // 1. 暂存next，并将next 跳过
           ListNode next = curr.next;
           curr.next = next.next;
   
           // 2. 将跳过的next 头插 到 dummy之后
           next.next = dummy.next;
           dummy.next = next;
       }
       return dummy.next;
   }
   
   ```

2. 从 left 到 right 的 部分逆序。

   ``` java
   /**
    * 区间反转链表。
    * 思路：找到 preLeft， 使用头插法反转 left到right 即可。
    */
   public ListNode reverseBetween(ListNode head, int left, int right) {
       ListNode dummy = new ListNode(0, head);
       ListNode preLeft = dummy;
   
       // 1. 找到preLeft位置
       for (int i = 0; i < left - 1; i++) {
           preLeft = preLeft.next;
       }
   
       ListNode curr = preLeft.next;
   
       // 2. 对preLeft之后的链表 实施头插
       for (int i = 0; i < right - left; i++) {
           ListNode next = curr.next;
           curr.next = next.next;
           next.next = preLeft.next;
           preLeft.next = next;
       }
       
       return dummy.next;
   }
   
   ```

3. k个一组逆序

   ```
   
   ```

   
