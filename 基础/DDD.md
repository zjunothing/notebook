# DDD

## OX01 理论

1. ddd的引入，为什么要ddd

   1. 微服务如何拆分没有理论依据，ddd中 Bounded Context 恰好提供拆分依据。 按照ddd中界限上下文来拆分，即按照业务耦合度来拆分。（划分领域边界，再根据这些领域边界从业务视角来划分微服务边界）

   2. 强调业务的重要性，强调理解业务，对业务合理建模

   3. 强调业务概念显性化出来。 原来是一段 transaction script， 现在是一个 业务实体+实体行为

   4. 但是今天我们在做业务研发时，更多的会去关注一些宏观的架构，比如SOA架构、微服务架构（纯技术），而忽略了应用内部的架构设计（关注业务本身），很容易导致代码逻辑混乱，很难维护

      

      

2. 战略和战术

   1. 战略（偏业务）： 业务分析，确定领域模型、划分领域、确定领域边界、建立统一语言
   2. 战术（偏技术）：实体、值对象、聚合根，领域服务，资源库，代码分层等技术指导。

3. Domian，subDomain，BoundedContext

   1. domain/subDomain： 业务问题域。 每一个细分领域，其实都有一个知识体系。

   2. BC： 解空间。

      

4. 实体、值对象

   1. 将关键业务概念抽象出来，形成实体或者值对象。 **业务概念显性化**
   2. **领域原语**。 DomainPrimitive， 比如账号域，有Account，Address，Phone等。 DSL
   3. 有了DSL的好处
      1. 概念显性出来了
      2. 业务逻辑收敛起来了
      3. 通过原语对象的组装，来实现业务逻辑，可扩展性增加了（对比原来的事务脚本）。 有点类似原子能力的组装来增加可扩展性
      4. 在事务脚本式的架构下，一般做第一个需求都非常的快，但是做第N个需求时需要的时间很有可能是呈指数级上升的，绝大部分时间花费在老功能的重构和兼容上（类似的linux管道命令，基建原子命令做好了之后，后续的新命令就可以基于已有的基建命令很快实现了）
   4. 行为和属性尽量放在一起。 面向对象的 **信息专家** 原则。
   5. 领域层尽量多的 **吃掉业务逻辑** 。  将业务领域知识沉淀掉，构建一套业务原语（DSL）
   6. 做新功能时，基于已有的DP来做，代码复用

5. 聚合

   1. 将实体、值对象组装在一起，作为一个整体被访问
   2. 聚合内对象可互相引用，聚合外通过聚合ID引用，这样容易梳理清楚这么对对象的关系。
   3. 设计尽量小的聚合，因为不够灵活。
   4. 