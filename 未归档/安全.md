# 安全

### 一、mybatis #{} 和 ${} 却别

1. select * from table where column =  #{}   会走 `预编译`，出来的是 select * from table where column = ?    传入的参数会自动加上引号（所以表名、order by 的字段名 不能用 #{} ），通过预先生成SQL语句语法树的方式，使得传入的数据永远也无法成为一个动作。 

2. select * from table where column = ${}  不会走预编译，出来的sql 是直接将 参数部分 `拼接` 在 sql末尾。 所以很容易可以构造： select * from table where column = x; drop table   这样的sql来。

3. > 通俗的讲，预编译防止SQL注入的原理是提前编译SQL语句，将所有的用户输入都当做『数据』，而非『语法』

4. **预编译是不支持动态的表名、字段名的** （因为动态表名和字段名会导致执行路径不确定）。 

   ![image-20220415162624268](/Users/zjunothing/Library/Application Support/typora-user-images/image-20220415162624268.png)

5. ![image-20220415164649379](/Users/zjunothing/Library/Application Support/typora-user-images/image-20220415164649379.png)

   1. 字段名、表名这些，本身就无法进行预编译；
   2. 表名与列名是不能被预编译的，这是由于在预编译生成语法树的过程中，预处理器在检查解析后的语法树时，会确定数据表和数据列是否存在，此两者必须为具体值。
   3. 即使你调用 PrepareStatment 给你转义了一下，转义出来的sql也不是你想要的，因为加了引号。

6. 真正的预编译需要开启设置，否则dbms不会走真的预编译。 Java中也是默认由其本身进行转义后直接运行无危害语句的，若想使用真正的预编译，必须在连接数据库时加上useServerPrepStmts=true。如下，`String DB_URL = "jdbc:mysql://localhost:3306/test?useServerPrepStmts=true";`

#### 结论：

1. 尽量使用 #{}；动态表名、order by 字段名等一些特殊场景下，使用 ${},  不过要事先对传入的 参数 做 白名单过滤。如只允许字母数字下划线。

Reference:

1. https://blog.nowcoder.net/n/9d9987c816214f62b9266276da65e11f 深入理解SQL注入与预编译（上）
2. https://blog.nowcoder.net/n/be73b8f592504ae8b1d00368433061be 深入理解SQL注入与预编译（下） **重点看下这篇文章的 预编译时代的注入**





## OX02 补码

```
一、 以8位有符号数来举例。
	* 使用补码的目的：简化计算机基本运算电路，使加减法都只需要用加法电路实现，用加法替代减法。
	
	* 补码为什么能达到这个目的：n位二进制可以构成一个可溢出计数系统，在这样的系统中，把计数系统容量作为模，所有对此模同余的数在此计数系统中都会有同样的表示，而且运算等价。而补码就是负数的最小正同余数，所以加一个负数可以用加一个补码来表示。

另外使用补码之后，负数表述的范围可以多一个数（即最小负数）。 

如果是原码表示的话，编码中+0是用16个0表示，-0是用1后跟15个0表示
但是由于+0等于-0所以相当于多花了一个编码来编码0

那么用补码会怎样
补码+0编码出来是16个0
-0 = [1000000000000000]原 = [1111111111111111]反 = [(1)0000000000000000]补
其中1溢出不管了 剩下的是16个0与+0编码相同

这样一来用16位进行编码如果按原码编码可以覆盖-32767~32767[1111111111111111~0111111111111111]
而用补码编码只覆盖到[1000 0000 0000 0001 ~ 0111 1111 1111 1111]其中[1000000000000000]补 用不到
于是规定了用它表示最小值-32768

因此，在考虑16位有符号整数时，-32768只有补码[1000000000000000],没有原码，只是硬性规定补码[1000000000000000]表示 -32768

当然如果你考虑的是大于16位来编码的话，-32768肯定能正常编码,-32768 的正常编码如下：
源码 1 1000 0000 0000 0000
反码 1 0111 1111 1111 1111
补码 1 0111 1111 1111 1111 
      + 1
      =1 1000 0000 0000 0000
所以正常的-32768的补码应该是要17位表示，为1 1000 0000 0000 0000

参考： https://juejin.cn/post/6844904015298297863
```







